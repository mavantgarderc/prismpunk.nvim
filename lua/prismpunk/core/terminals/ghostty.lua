local M = {}

local punkpalette = require("prismpunk.palette")
local punkconf = require("prismpunk.config")

local uv = vim.uv or vim.loop
local reload_timer

M.export_toml = function(theme)
  local c = theme.colors
  local lines = {
    "# " .. theme.name,
    "# Generated by prismpunk.nvim",
    "# " .. os.date("%Y-%m-%d %H:%M:%S"),
    "",
    "palette = 0=" .. c.base00,
    "palette = 1=" .. c.base08,
    "palette = 2=" .. c.base0B,
    "palette = 3=" .. c.base0A,
    "palette = 4=" .. c.base0D,
    "palette = 5=" .. c.base0E,
    "palette = 6=" .. c.base0C,
    "palette = 7=" .. c.base05,
    "palette = 8=" .. c.base03,
    "palette = 9=" .. c.base08,
    "palette = 10=" .. c.base0B,
    "palette = 11=" .. c.base0A,
    "palette = 12=" .. c.base0D,
    "palette = 13=" .. c.base0E,
    "palette = 14=" .. c.base0C,
    "palette = 15=" .. c.base07,
    "background = " .. c.base00,
    "foreground = " .. c.base05,
    "cursor-color = " .. c.base05,
    "cursor-text = " .. c.base00,
    "selection-background = " .. c.base02,
    "selection-foreground = " .. c.base05,
  }
  return table.concat(lines, "\n")
end

M.write_config = function(theme, path)
  local content = M.export_toml(theme)
  path = vim.fn.expand(path)
  vim.fn.mkdir(vim.fn.fnamemodify(path, ":h"), "p")
  local file = io.open(path, "w")
  if not file then
    vim.notify("Prismpunk: Failed to write " .. path, vim.log.levels.ERROR)
    return false
  end
  file:write(content)
  file:close()
  return true
end

local function reload_ghostty_async()
  vim.system({ "pkill", "-USR2", "ghostty" }, { detach = true }, function(obj)
    if obj.code ~= 0 then
      vim.schedule(function() vim.notify("Prismpunk: Failed to reload Ghostty automatically", vim.log.levels.WARN) end)
    end
  end)
end

local function schedule_reload_debounced(delay_ms)
  if not uv or not uv.new_timer then
    vim.defer_fn(reload_ghostty_async, delay_ms)
    return
  end
  if not reload_timer then
    reload_timer = uv.new_timer()
  else
    reload_timer:stop()
  end
  reload_timer:start(delay_ms, 0, function()
    reload_timer:stop()
    vim.schedule(reload_ghostty_async)
  end)
end

M.reload = function()
  reload_ghostty_async()
  return true
end

M.export_and_reload = function(theme, conf)
  local success = M.write_config(theme, conf.config_path)
  if success and conf.auto_reload then schedule_reload_debounced(400) end
end

M.export = function(theme_name)
  local parsed = punkconf.parse_theme(theme_name)
  local theme_path
  if parsed.universe then
    theme_path = "prismpunk.themes." .. parsed.universe:gsub("%-", "%.") .. "." .. parsed.name
  else
    theme_path = "prismpunk.themes." .. parsed.name
  end
  local ok, spec = pcall(require, theme_path)
  if not ok then
    vim.notify("Failed to load theme: " .. theme_name, vim.log.levels.ERROR)
    return nil
  end
  return M.export_toml(punkpalette.create_theme(spec))
end

M.save = function(theme_name, output_path)
  output_path = output_path or vim.fn.expand("~/.config/ghostty/themes/prismpunk.toml")
  local parsed = punkconf.parse_theme(theme_name)
  local theme_path
  if parsed.universe then
    theme_path = "prismpunk.themes." .. parsed.universe:gsub("%-", "%.") .. "." .. parsed.name
  else
    theme_path = "prismpunk.themes." .. parsed.name
  end
  local ok, spec = pcall(require, theme_path)
  if not ok then
    vim.notify("Failed to load theme: " .. theme_name, vim.log.levels.ERROR)
    return
  end
  local _ = M.write_config(punkpalette.create_theme(spec), output_path)
end

return M
